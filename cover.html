
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>node-observability-agent: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/openshift/node-observability-agent/cmd/node-observability-agent/main.go (54.3%)</option>
				
				<option value="file1">github.com/openshift/node-observability-agent/pkg/handlers/handlers.go (72.7%)</option>
				
				<option value="file2">github.com/openshift/node-observability-agent/pkg/handlers/profiling_handlers.go (92.9%)</option>
				
				<option value="file3">github.com/openshift/node-observability-agent/pkg/handlers/scripting_handlers.go (100.0%)</option>
				
				<option value="file4">github.com/openshift/node-observability-agent/pkg/statelocker/statelocker.go (89.8%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "crypto/x509"
        "flag"
        "fmt"
        "net"
        "os"
        "syscall"

        log "github.com/sirupsen/logrus"

        "github.com/openshift/node-observability-agent/pkg/server"
        ver "github.com/openshift/node-observability-agent/pkg/version"
)

var (
        nodeIP               = os.Getenv("NODE_IP")
        port                 = flag.Int("port", 9000, "server port to listen on (default: 9000)")
        unixSocket           = flag.String("unixSocket", "/var/run/nobagent.sock", "unix socket to listen on (default: /var/run/nobagent.sock)")
        preferUnixSocket     = flag.Bool("preferUnixSocket", false, "listen on the unix socket instead of localhost:port")
        storageFolder        = flag.String("storage", "/tmp/pprofs/", "folder to which the pprof files are saved")
        tokenFile            = flag.String("tokenFile", "", "file containing token to be used for kubelet profiling http request")
        caCertFile           = flag.String("caCertFile", "/var/run/secrets/kubernetes.io/serviceaccount/kubelet-serving-ca.crt", "file containing CAChain for verifying the TLS certificate on kubelet profiling http request")
        crioUnixSocket       = flag.String("crioUnixSocket", "/var/run/crio/crio.sock", "file referring to the unix socket to be used for CRIO profiling")
        crioPreferUnixSocket = flag.Bool("crioPreferUnixSocket", true, "use unix socket to communicate to CRIO")
        logLevel             = flag.String("loglevel", "info", "log level")
        versionFlag          = flag.Bool("v", false, "print version")
        mode                 = flag.String("mode", "profiling", "flag (profiling or scripting) to set mode (crio,kubelet) profiling or metrics script execution")
)

func main() <span class="cov0" title="0">{
        flag.Parse()

        if *versionFlag </span><span class="cov0" title="0">{
                fmt.Println(ver.MakeVersionString())
                os.Exit(0)
        }</span>

        // Gosec G304 (CWE-22) - Mitigated
        // This is a parameter passed via a command line. The agent only takes the token file from this parameter
        // and cannot be changed as it is not exposed via an environmental variable , configmap or secret
        <span class="cov0" title="0">lvl, err := log.ParseLevel(*logLevel)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("Log level %s not recognized, using info", *logLevel)
                *logLevel = "info"
                lvl = log.InfoLevel
        }</span>
        <span class="cov0" title="0">log.SetLevel(lvl)
        log.Infof("Starting %s at log level %s", ver.MakeVersionString(), *logLevel)

        checkParameters(nodeIP, *storageFolder, *crioUnixSocket, *crioPreferUnixSocket, *caCertFile)

        /* #nosec G304 tokenFile is a parameter of the agentâ€™s go program.
        *  Upon creation of the NodeObservability CR, the operator creates a SA for the agent, sets its RBAC,
        * and provides the tokenFile parameter in the daemonset manifest: The value provided is the default file
        * kubernetes mounts on the node containing the SA JWT)
        * The agent only takes the token file from that
         */
        token, err := readTokenFile(*tokenFile)
        if err != nil </span><span class="cov0" title="0">{
                panic("Unable to read token file, or token is empty :" + err.Error())</span>
        }

        <span class="cov0" title="0">caCerts, err := makeCACertPool(*caCertFile)
        if err != nil </span><span class="cov0" title="0">{
                panic("Unable to read caCerts file :" + err.Error())</span>
        }

        <span class="cov0" title="0">if err := server.Start(server.Config{
                Port:                 *port,
                UnixSocket:           *unixSocket,
                PreferUnixSocket:     *preferUnixSocket,
                Token:                token,
                CACerts:              caCerts,
                StorageFolder:        *storageFolder,
                CrioUnixSocket:       *crioUnixSocket,
                CrioPreferUnixSocket: *crioPreferUnixSocket,
                NodeIP:               nodeIP,
        }); err != nil </span><span class="cov0" title="0">{
                log.Errorf("Error from server: %s", err.Error())
        }</span>
        <span class="cov0" title="0">log.Info("Stopped")</span>
}

func checkParameters(nodeIP, storageFolder, crioUnixSocket string, crioPreferUnixSocket bool, caCertFile string) <span class="cov8" title="1">{
        //check on configs that are passed along before starting up the server
        //1. nodeIP is found
        if nodeIP == "" || net.ParseIP(nodeIP) == nil </span><span class="cov8" title="1">{
                panic("Environment variable NODE_IP not found, or doesn't contain a valid IP address")</span>
        }
        //2. StorageFolder is accessible in readwrite
        <span class="cov8" title="1">if err := syscall.Access(storageFolder, syscall.O_RDWR); err != nil </span><span class="cov8" title="1">{
                panic(fmt.Sprintf("Unable to access the storage folder for saving the profiling data %q: %v", storageFolder, err))</span>
        }
        //3. CRIO socket is accessible in readwrite
        <span class="cov8" title="1">if crioPreferUnixSocket </span><span class="cov8" title="1">{
                if err := syscall.Access(crioUnixSocket, syscall.O_RDWR); err != nil </span><span class="cov8" title="1">{
                        panic(fmt.Sprintf("Unable to access the crio socket %q: %v", crioUnixSocket, err))</span>
                }
        }
        //4. CACerts file is readable
        <span class="cov8" title="1">const R_OK uint32 = 4
        if syscall.Access(caCertFile, R_OK) != nil </span><span class="cov8" title="1">{
                panic("Unable to read the caCerts file :" + caCertFile)</span>
        }
}

func readTokenFile(tokenFile string) (string, error) <span class="cov8" title="1">{
        content, err := os.ReadFile(tokenFile)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>
        <span class="cov8" title="1">if len(content) &lt;= 0 </span><span class="cov8" title="1">{
                return "", fmt.Errorf("%s was empty", tokenFile)
        }</span>
        <span class="cov8" title="1">return string(content), nil</span>
}

func makeCACertPool(caCertFile string) (*x509.CertPool, error) <span class="cov8" title="1">{
        content, err := os.ReadFile(caCertFile)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if len(content) &lt;= 0 </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("%s was empty", caCertFile)
        }</span>
        <span class="cov8" title="1">caCertPool := x509.NewCertPool()
        if !caCertPool.AppendCertsFromPEM(content) </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("Unable to add certificates into caCertPool:\n%v", err)

        }</span>
        <span class="cov8" title="1">return caCertPool, nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package handlers

import (
        "bytes"
        "crypto/x509"
        "encoding/json"
        "fmt"
        "io"
        "net/http"
        "os"
        "path/filepath"
        "time"

        "github.com/google/uuid"
        "github.com/sirupsen/logrus"

        "github.com/openshift/node-observability-agent/pkg/connectors"
        "github.com/openshift/node-observability-agent/pkg/runs"
        "github.com/openshift/node-observability-agent/pkg/statelocker"
)

const (
        ready                    = "Service is ready"
        httpRespErrMsg           = "unable to send response"
        baseTimeout       int    = 35
        logFileExt        string = "log"
        errorFileExt      string = "err"
        pprofFileExt      string = "pprof"
        crioFilePrefix    string = "crio"
        kubeletFilePrefix string = "kubelet"
)

var (
        hlog = logrus.WithField("module", "handler")
)

// Handlers holds the parameters necessary for running the CRIO, Kubelet profiling as well as scripting
type Handlers struct {
        Token                string
        NodeIP               string
        StorageFolder        string
        CrioUnixSocket       string
        CrioPreferUnixSocket bool
        CACerts              *x509.CertPool
        stateLocker          statelocker.StateLocker
        Connector            connectors.CmdWrapper
        Mode                 string
}

// NewHandlers creates a new instance of Handlers from the given parameters
func NewHandlers(token string, caCerts *x509.CertPool, storageFolder string, crioUnixSocket string, nodeIP string, crioPreferUnixSocket bool) *Handlers <span class="cov8" title="1">{
        h := &amp;Handlers{
                Token:                token,
                CACerts:              caCerts,
                NodeIP:               nodeIP,
                StorageFolder:        storageFolder,
                CrioUnixSocket:       crioUnixSocket,
                CrioPreferUnixSocket: crioPreferUnixSocket,
                Mode:                 "profiling",
        }
        h.stateLocker = statelocker.NewStateLock(h.errorOutputFilePath())
        return h
}</span>

// NewScriptingHandlers creates a new instance of Handlers from the given parameters
func NewScriptingHandlers(storageFolder string, nodeIP string) *Handlers <span class="cov8" title="1">{
        h := &amp;Handlers{
                NodeIP:        nodeIP,
                StorageFolder: storageFolder,
                Connector:     &amp;connectors.Connector{},
                Mode:          "scripting",
        }
        h.stateLocker = statelocker.NewStateLock(h.errorOutputFilePath())
        return h
}</span>

// Status is called when the agent receives an HTTP request on endpoint /status.
// It returns:
// * HTTP 500 if the agent is in error,
// * HTTP 409 if a previous profiling is still ongoing,
// * HTTP 200 if the agent is ready
func (h *Handlers) Status(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        hlog.Infof("start handling status request")

        id, state, err := h.stateLocker.LockInfo()
        if err != nil </span><span class="cov8" title="1">{
                http.Error(w, "error retrieving service status", http.StatusInternalServerError)
                hlog.Errorf("error retrieving service status : %v", err)
                return
        }</span>
        <span class="cov8" title="1">switch state </span>{
        case statelocker.InError:<span class="cov8" title="1">
                hlog.Infof("agent is in error state, runID: %s", id.String())
                err = respondBusyOrError(id.String(), w, true)
                if err != nil </span><span class="cov0" title="0">{
                        http.Error(w, httpRespErrMsg, http.StatusInternalServerError)
                        hlog.Error(err)
                        return
                }</span>
        case statelocker.Taken:<span class="cov8" title="1">
                hlog.Infof("previous profiling is still ongoing, runID: %s", id.String())
                err := respondBusyOrError(id.String(), w, false)
                if err != nil </span><span class="cov0" title="0">{
                        http.Error(w, httpRespErrMsg, http.StatusInternalServerError)
                        hlog.Error(err)
                        return
                }</span>
        case statelocker.Free:<span class="cov8" title="1">
                hlog.Info("agent is ready")
                _, err := w.Write([]byte(ready))
                if err != nil </span><span class="cov0" title="0">{
                        hlog.Errorf("could not send response busy : %v", err)
                }</span>
        }
}

// HandleProfiling is called when the agent receives an HTTP request on endpoint /pprof
// After checking the agent is not in error, and that no previous profiling is still ongoing,
// it triggers the kubelet and CRIO profiling in separate goroutines, and launches a separate
// function to process the results in a goroutine as well
func (h *Handlers) HandleProfiling(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        hlog.Info("start handling profiling request")

        uid, state, err := h.stateLocker.Lock()
        if err != nil </span><span class="cov8" title="1">{
                http.Error(w, "service is either busy or in error, try again", http.StatusInternalServerError)
                hlog.Error(err)
                return
        }</span>

        <span class="cov8" title="1">switch state </span>{
        case statelocker.InError:<span class="cov8" title="1">
                </span><span class="cov8" title="1">{
                        hlog.Infof("agent is in error state, runID: %s", uid.String())
                        err := respondBusyOrError(uid.String(), w, true)
                        if err != nil </span><span class="cov0" title="0">{
                                http.Error(w, httpRespErrMsg, http.StatusInternalServerError)
                                hlog.Error(err)
                                return
                        }</span>
                        <span class="cov8" title="1">return</span>
                }
        case statelocker.Taken:<span class="cov8" title="1">
                </span><span class="cov8" title="1">{
                        hlog.Infof("previous profiling is still ongoing, runID: %s", uid.String())
                        err := respondBusyOrError(uid.String(), w, false)
                        if err != nil </span><span class="cov0" title="0">{
                                http.Error(w, httpRespErrMsg, http.StatusInternalServerError)
                                hlog.Error(err)
                                return
                        }</span>
                        <span class="cov8" title="1">return</span>
                }
        case statelocker.Free:<span class="cov8" title="1">
                </span><span class="cov8" title="1">{
                        hlog.Infof("ready to initiate profiling, runID: %s", uid.String())
                        // Channel for collecting results of profiling
                        runResultsChan := make(chan runs.ExecutionRun)

                        // Launch both profilings in parallel as well as the routine to wait for results
                        go func() </span><span class="cov8" title="1">{
                                runResultsChan &lt;- h.profileKubelet(uid.String())
                        }</span>()

                        <span class="cov8" title="1">go func() </span><span class="cov8" title="1">{
                                runResultsChan &lt;- h.profileCrio(uid.String())
                        }</span>()

                        <span class="cov8" title="1">go h.processResults(uid, runResultsChan, baseTimeout)
                        // Send a HTTP 200 straight away
                        err := sendUID(w, uid)
                        if err != nil </span><span class="cov0" title="0">{
                                hlog.Error(err)
                                return
                        }</span>
                }
        }
}

// HandleScripting is called when the agent receives an HTTP request on endpoint /scripting
// After checking the agent is not in error, and that no previous profiling is still ongoing,
// it triggers the embedded script in a separate goroutine, and launches a separate
// function to process the results in a goroutine as well
func (h *Handlers) HandleScripting(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        uid, state, err := h.stateLocker.Lock()
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "service is either busy or in error, try again",
                        http.StatusInternalServerError)
                hlog.Error(err)
                return
        }</span>

        <span class="cov8" title="1">switch state </span>{
        case statelocker.InError:<span class="cov0" title="0">
                </span><span class="cov0" title="0">{
                        err := respondBusyOrError(uid.String(), w, true)
                        if err != nil </span><span class="cov0" title="0">{
                                http.Error(w, httpRespErrMsg,
                                        http.StatusInternalServerError)
                                hlog.Error(httpRespErrMsg)
                                return
                        }</span>
                        <span class="cov0" title="0">return</span>
                }
        case statelocker.Taken:<span class="cov0" title="0">
                </span><span class="cov0" title="0">{
                        err := respondBusyOrError(uid.String(), w, false)
                        if err != nil </span><span class="cov0" title="0">{
                                http.Error(w, httpRespErrMsg,
                                        http.StatusInternalServerError)
                                hlog.Error(httpRespErrMsg)
                                return
                        }</span>
                        <span class="cov0" title="0">return</span>
                }
        case statelocker.Free:<span class="cov8" title="1">
                </span><span class="cov8" title="1">{

                        // Channel for collecting results of metrics
                        runResultsChan := make(chan runs.ExecutionRun)

                        // Launch metrics script as the routine to wait for results
                        go func() </span><span class="cov8" title="1">{
                                h.Connector.Prepare("sh", []string{"-c", "scripts/all_metrics.sh"})
                                runResultsChan &lt;- h.executeScript(uid.String(), h.Connector)
                        }</span>()

                        <span class="cov8" title="1">go h.processResults(uid, runResultsChan, 7200)
                        // Send a HTTP 200 straight away
                        err := sendUID(w, uid)
                        if err != nil </span><span class="cov0" title="0">{
                                hlog.Error(err)
                                return
                        }</span>
                }
        }
}

func (h *Handlers) processResults(uid uuid.UUID, runResultsChan chan runs.ExecutionRun, timeout int) <span class="cov8" title="1">{
        arun := runs.Run{
                ID:            uid,
                ExecutionRuns: []runs.ExecutionRun{},
        }
        // unlock as soon as finished processing
        defer func() </span><span class="cov8" title="1">{
                err := h.stateLocker.Unlock()
                if err != nil </span><span class="cov0" title="0">{
                        hlog.Fatal(err)
                }</span>
                <span class="cov8" title="1">close(runResultsChan)</span>
        }()

        <span class="cov8" title="1">if h.Mode == "profiling" </span><span class="cov8" title="1">{
                // wait for the results
                arun.ExecutionRuns = []runs.ExecutionRun{}
                isTimeout := false

                hlog.Infof("start processing results of profiling requests, runID: %s", uid.String())
                for nb := 0; nb &lt; 2 &amp;&amp; !isTimeout; </span><span class="cov8" title="1">{
                        select </span>{
                        case er := &lt;-runResultsChan:<span class="cov8" title="1">
                                nb++
                                arun.ExecutionRuns = append(arun.ExecutionRuns, er)</span>
                        case &lt;-time.After(time.Second * time.Duration(timeout)):<span class="cov8" title="1">
                                //timeout! dont wait anymore
                                erInTimeout := runs.ExecutionRun{
                                        Type:       runs.UnknownRun,
                                        Successful: false,
                                        BeginTime:  time.Now(),
                                        EndTime:    time.Now(),
                                        Error:      fmt.Sprintf("timeout after waiting %ds", timeout),
                                }
                                erInTimeout.Error = fmt.Sprintf("timeout after waiting %ds", timeout)
                                arun.ExecutionRuns = append(arun.ExecutionRuns, erInTimeout)
                                isTimeout = true</span>
                        }
                }
        } else<span class="cov8" title="1"> {
                select </span>{
                case er := &lt;-runResultsChan:<span class="cov8" title="1">
                        arun.ExecutionRuns = append(arun.ExecutionRuns, er)</span>
                case &lt;-time.After(time.Second * time.Duration(timeout)):<span class="cov0" title="0">
                        //timeout! dont wait anymore
                        erInTimeout := runs.ExecutionRun{
                                Type:       runs.UnknownRun,
                                Successful: false,
                                BeginTime:  time.Now(),
                                EndTime:    time.Now(),
                                Error:      fmt.Sprintf("timeout after waiting %ds", timeout),
                        }
                        erInTimeout.Error = fmt.Sprintf("timeout after waiting %ds", timeout)
                        arun.ExecutionRuns = append(arun.ExecutionRuns, erInTimeout)</span>
                }
        }

        // Process the results
        <span class="cov8" title="1">var errorMessage bytes.Buffer
        var logMessage bytes.Buffer
        for _, execRun := range arun.ExecutionRuns </span><span class="cov8" title="1">{
                if execRun.Error != "" </span><span class="cov8" title="1">{
                        errorMessage.WriteString("errors encountered while running " + string(execRun.Type) + " - " + arun.ID.String() + ":\n")
                        errorMessage.WriteString(execRun.Error + "\n")
                }</span>
                <span class="cov8" title="1">logMessage.WriteString("successfully finished running " + string(execRun.Type) + " - " + arun.ID.String() + ": " + execRun.BeginTime.String() + " -&gt; " + execRun.EndTime.String() + " ")</span>
        }

        <span class="cov8" title="1">if errorMessage.Len() &gt; 0 </span><span class="cov8" title="1">{
                hlog.Error(errorMessage.String())
                err := h.stateLocker.SetError(arun)
                if err != nil </span><span class="cov0" title="0">{
                        hlog.Fatal(err)
                }</span>
        } else<span class="cov8" title="1"> {
                // no errors : simply log the results
                hlog.Info(logMessage.String())
                if err := writeRunToFile(arun, h.runLogOutputFilePath(arun)); err != nil </span><span class="cov0" title="0">{
                        hlog.Fatal(err)
                }</span>
        }
}

// outputFilePath returns the full file path from the storage folder.
func (h *Handlers) outputFilePath(prefix, id, ext string) string <span class="cov8" title="1">{
        if prefix != "" </span><span class="cov8" title="1">{
                prefix = prefix + "-"
        }</span>
        <span class="cov8" title="1">return filepath.Join(h.StorageFolder, prefix+id+"."+ext)</span>
}

// crioPprofOutputFilePath returns the full file path for CRIO pprof output.
func (h *Handlers) crioPprofOutputFilePath(id string) string <span class="cov8" title="1">{
        return h.outputFilePath(crioFilePrefix, id, pprofFileExt)
}</span>

// kubeletPprofOutputFilePath returns the full file path for Kubelet pprof output.
func (h *Handlers) kubeletPprofOutputFilePath(id string) string <span class="cov8" title="1">{
        return h.outputFilePath(kubeletFilePrefix, id, pprofFileExt)
}</span>

// runLogOutputFilePath returns the full file path for pprof output.
func (h *Handlers) runLogOutputFilePath(r runs.Run) string <span class="cov8" title="1">{
        return h.outputFilePath("", r.ID.String(), logFileExt)
}</span>

// errorOutputFilePath returns the full file path for error file.
func (h *Handlers) errorOutputFilePath() string <span class="cov8" title="1">{
        return h.outputFilePath("", "agent", errorFileExt)
}</span>

func sendUID(w http.ResponseWriter, runID uuid.UUID) error <span class="cov8" title="1">{
        response := runs.Run{
                ID: runID,
        }

        jsResponse, err := json.Marshal(response)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return fmt.Errorf("unable to marshal run instance %q: %w", runID, err)
        }</span>

        <span class="cov8" title="1">w.Header().Set("Content-Type", "application/json")
        _, err = w.Write(jsResponse)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unable to send HTTP response for run instance %q: %w", runID, err)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func respondBusyOrError(uid string, w http.ResponseWriter, isError bool) error <span class="cov8" title="1">{
        message := ""

        if isError </span><span class="cov8" title="1">{
                w.WriteHeader(http.StatusInternalServerError)
                message = uid + " failed."
        }</span> else<span class="cov8" title="1"> {
                w.WriteHeader(http.StatusConflict)
                message = uid + " still running"
        }</span>
        <span class="cov8" title="1">_, err := w.Write([]byte(message))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unable to send HTTP response, %w", err)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// writeRunToFile writes the contents of the run into the given file.
func writeRunToFile(run runs.Run, filePath string) error <span class="cov8" title="1">{
        bytes, err := json.Marshal(run)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unable to marshal run %q into json: %w", run.ID.String(), err)
        }</span>
        <span class="cov8" title="1">if err := os.WriteFile(filePath, bytes, 0600); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error writing run %q into file %q: %w", run.ID.String(), filePath, err)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// writeToFile writes the contents of the reader into the given file.
func writeToFile(reader io.ReadCloser, filePath string) error <span class="cov8" title="1">{
        out, err := os.Create(filePath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create file %s: %w", filePath, err)
        }</span>
        <span class="cov8" title="1">defer out.Close()

        if _, err := io.Copy(out, reader); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to write to file %s: %w", filePath, err)
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package handlers

import (
        "context"
        "crypto/tls"
        "crypto/x509"
        "fmt"
        "net"
        "net/http"
        "net/url"
        "time"

        "github.com/openshift/node-observability-agent/pkg/runs"
)

const (
        defaultCrioHost    = "localhost"
        defaultCrioPort    = "6060"
        defaultKubeletPort = "10250"
        crioProfilePath    = "debug/pprof/profile"
        kubeletProfilePath = "debug/pprof/profile"
)

// profileCrio triggers CRIO profiling on localhost.
func (h *Handlers) profileCrio(uid string) runs.ExecutionRun <span class="cov8" title="1">{
        client := &amp;http.Client{
                Transport: newDefaultHTTPTransport().build(),
        }
        if h.CrioPreferUnixSocket </span><span class="cov8" title="1">{
                client.Transport = newDefaultHTTPTransport().withUnixDialContext(h.CrioUnixSocket).build()
        }</span>

        <span class="cov8" title="1">u := url.URL{
                Scheme: "http",
                Host:   net.JoinHostPort(defaultCrioHost, defaultCrioPort),
                Path:   crioProfilePath,
        }

        hlog.Infof("requesting CRIO profiling, runID: %s", uid)
        return sendHTTPProfileRequest(runs.CrioRun, "GET", u.String(), "", h.crioPprofOutputFilePath(uid), client)</span>
}

// profileKubelet triggers Kubelet profiling on h.NodeIP using h.Token for authorization.
func (h *Handlers) profileKubelet(uid string) runs.ExecutionRun <span class="cov8" title="1">{
        client := &amp;http.Client{
                Transport: newDefaultHTTPTransport().withRootCAs(h.CACerts).build(),
        }

        u := url.URL{
                Scheme: "https",
                Host:   net.JoinHostPort(h.NodeIP, defaultKubeletPort),
                Path:   kubeletProfilePath,
        }

        hlog.Infof("requesting Kubelet profiling, runID: %s", uid)
        return sendHTTPProfileRequest(runs.KubeletRun, "GET", u.String(), h.Token, h.kubeletPprofOutputFilePath(uid), client)
}</span>

// sendHTTPProfileRequest sends the http request to the given url,
// writes the response down to the given output and returns the profiling run instance.
func sendHTTPProfileRequest(rtype runs.RunType, method, url, token, outputPath string, client *http.Client) runs.ExecutionRun <span class="cov8" title="1">{
        run := runs.ExecutionRun{
                Type:      rtype,
                BeginTime: time.Now(),
        }

        req, err := http.NewRequest(method, url, nil)
        if err != nil </span><span class="cov0" title="0">{
                run.EndTime = time.Now()
                run.Error = fmt.Sprintf("failed to create http request: %v", err)
                return run
        }</span>

        <span class="cov8" title="1">if token != "" </span><span class="cov8" title="1">{
                req.Header.Add("Authorization", "Bearer "+token)
        }</span>

        <span class="cov8" title="1">res, err := client.Do(req)
        if err != nil </span><span class="cov8" title="1">{
                run.EndTime = time.Now()
                run.Error = fmt.Sprintf("failed sending profiling request: %v", err)
                return run
        }</span>
        <span class="cov8" title="1">defer res.Body.Close()

        if res.StatusCode != http.StatusOK </span><span class="cov8" title="1">{
                run.EndTime = time.Now()
                run.Error = fmt.Sprintf("error status code received: %d", res.StatusCode)
                return run
        }</span>

        <span class="cov8" title="1">if err := writeToFile(res.Body, outputPath); err != nil </span><span class="cov8" title="1">{
                run.EndTime = time.Now()
                run.Error = fmt.Sprintf("failed writing profiling data into file: %v", err)
                return run
        }</span>

        <span class="cov8" title="1">run.EndTime = time.Now()
        run.Successful = true

        return run</span>
}

type httpTransportBuilder struct {
        tlsClientConfig *tls.Config
        dialContext     func(ctx context.Context, network, addr string) (net.Conn, error)
}

func newDefaultHTTPTransport() *httpTransportBuilder <span class="cov8" title="1">{
        return &amp;httpTransportBuilder{
                dialContext: (&amp;net.Dialer{Timeout: 30 * time.Second, KeepAlive: 30 * time.Second}).DialContext,
        }
}</span>

func (b *httpTransportBuilder) withRootCAs(certs *x509.CertPool) *httpTransportBuilder <span class="cov8" title="1">{
        b.tlsClientConfig = &amp;tls.Config{RootCAs: certs, MinVersion: tls.VersionTLS12}
        return b
}</span>

func (b *httpTransportBuilder) withUnixDialContext(socket string) *httpTransportBuilder <span class="cov8" title="1">{
        b.dialContext = func(ctx context.Context, _, _ string) (net.Conn, error) </span><span class="cov8" title="1">{
                return (&amp;net.Dialer{Timeout: 30 * time.Second, KeepAlive: 30 * time.Second}).DialContext(ctx, "unix", socket)
        }</span>
        <span class="cov8" title="1">return b</span>
}

func (b *httpTransportBuilder) build() *http.Transport <span class="cov8" title="1">{
        return &amp;http.Transport{
                Proxy:                 http.ProxyFromEnvironment,
                DialContext:           b.dialContext,
                TLSClientConfig:       b.tlsClientConfig,
                ForceAttemptHTTP2:     true,
                MaxIdleConns:          100,
                IdleConnTimeout:       90 * time.Second,
                TLSHandshakeTimeout:   10 * time.Second,
                ExpectContinueTimeout: 1 * time.Second,
        }
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package handlers

import (
        "fmt"
        "time"

        "github.com/openshift/node-observability-agent/pkg/connectors"
        "github.com/openshift/node-observability-agent/pkg/runs"
)

// executeScript executes the embedded script on the h.NodeIP
func (h *Handlers) executeScript(uid string, cmd connectors.CmdWrapper) runs.ExecutionRun <span class="cov8" title="1">{
        run := runs.ExecutionRun{
                Type:      runs.ScriptingRun,
                BeginTime: time.Now(),
        }

        message, err := cmd.CmdExec()
        run.EndTime = time.Now()
        if err != nil </span><span class="cov8" title="1">{
                run.Error = fmt.Sprintf("error executing script :\n%s", message)
        }</span> else<span class="cov8" title="1"> {
                run.Successful = true
                hlog.Infof("%s", message)
        }</span>
        <span class="cov8" title="1">return run</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package statelocker

import (
        "encoding/json"
        "fmt"
        "os"
        "sync"

        "github.com/google/uuid"

        "github.com/openshift/node-observability-agent/pkg/runs"
)

type State string

const (
        Free    State = "FREE"
        Taken   State = "TAKEN"
        InError State = "ERROR"
)

type StateLocker interface {
        Lock() (uuid.UUID, State, error)
        SetError(runInError runs.Run) error
        Unlock() error
        LockInfo() (uuid.UUID, State, error)
}

// StateLock struct holds the state of the agent service
// and ensures its update in racy conditions
type StateLock struct {
        mux           *sync.Mutex
        takerID       uuid.UUID
        errorFilePath string
}

// NewStateLock creates a mutex for syncing the agent service state
// the pathToErr parameter is the path to the error file which might
// be created in case a profiling request is in error.
func NewStateLock(pathToErr string) *StateLock <span class="cov8" title="1">{
        return &amp;StateLock{
                mux:           &amp;sync.Mutex{},
                errorFilePath: pathToErr,
                takerID:       uuid.Nil,
        }
}</span>

// StateLock attempts to take the single token available
// The first return param is the UID of the job holding the lock
// According to the value of the second return param (state), this
// uuid is either a newly created UUID, or the one from the ongoing job
// The second return parameter is the State: Free is returned in case of success, Taken is returned in case
// a previous job is still running, InError is returned in case the errorFile exists
// The last parameter returned is the error encountered, if any
func (m *StateLock) Lock() (uuid.UUID, State, error) <span class="cov8" title="1">{
        m.mux.Lock()
        defer m.mux.Unlock()
        if m.takerID != uuid.Nil </span><span class="cov8" title="1">{
                return m.takerID, Taken, nil
        }</span>
        <span class="cov8" title="1">if m.errorFileExists() </span><span class="cov8" title="1">{
                uid, err := m.readUIDFromFile()
                if err != nil </span><span class="cov8" title="1">{
                        return uuid.Nil, InError, err
                }</span>
                <span class="cov8" title="1">return uid, InError, nil</span>
        }
        <span class="cov8" title="1">m.takerID = uuid.New()
        return m.takerID, Free, nil</span>
}

func (m *StateLock) SetError(runInError runs.Run) error <span class="cov8" title="1">{
        m.mux.Lock()
        defer m.mux.Unlock()
        if runInError.ID != uuid.Nil </span><span class="cov8" title="1">{
                return m.writeRunToErrorFile(runInError)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *StateLock) Unlock() error <span class="cov8" title="1">{
        m.mux.Lock()
        defer m.mux.Unlock()
        m.takerID = uuid.Nil
        return nil
}</span>

func (m *StateLock) LockInfo() (uuid.UUID, State, error) <span class="cov8" title="1">{
        m.mux.Lock()
        defer m.mux.Unlock()
        if m.errorFileExists() </span><span class="cov8" title="1">{
                uid, err := m.readUIDFromFile()
                if err != nil </span><span class="cov0" title="0">{
                        return uuid.Nil, InError, err
                }</span>
                <span class="cov8" title="1">return uid, InError, nil</span>
        }
        <span class="cov8" title="1">if m.takerID != uuid.Nil </span><span class="cov8" title="1">{
                return m.takerID, Taken, nil
        }</span>
        <span class="cov8" title="1">return m.takerID, Free, nil</span>
}

func (m *StateLock) errorFileExists() bool <span class="cov8" title="1">{
        if _, err := os.Stat(m.errorFilePath); err != nil </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">return true</span>
}

func (m *StateLock) readUIDFromFile() (uuid.UUID, error) <span class="cov8" title="1">{
        var arun *runs.Run = &amp;runs.Run{}
        contents, err := os.ReadFile(m.errorFilePath)
        if err != nil </span><span class="cov0" title="0">{
                return uuid.Nil, err
        }</span>
        <span class="cov8" title="1">err = json.Unmarshal(contents, arun)
        if err != nil </span><span class="cov8" title="1">{
                return uuid.Nil, err
        }</span>
        <span class="cov8" title="1">return arun.ID, nil</span>
}

// G306 (CWE-276) - Mitigated
// Changed permissions from 0644 to 0600
func (m *StateLock) writeRunToErrorFile(arun runs.Run) error <span class="cov8" title="1">{
        bytes, err := json.Marshal(arun)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error while creating %s file : unable to marshal run of ID %s\n%w", string(m.errorFilePath), arun.ID.String(), err)
        }</span>
        <span class="cov8" title="1">err = os.WriteFile(m.errorFilePath, bytes, 0600)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error writing  %s file: %w", m.errorFilePath, err)
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
